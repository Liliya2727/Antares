/*
 * Copyright (C) 2024-2025 Zexshia
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import BannerDarkZenith from "/webui.bannerdarkmode.avif";
import BannerLightZenith from "/webui.bannerlightmode.avif";
import AvatarZenith from "/webui.avatar.avif";
import SchemeBanner from "/webui.schemebanner.avif";
import ResoBanner from "/webui.reso.avif";
import { exec, toast } from "kernelsu";
const moduleInterface = window.$azenith;
const fileInterface = window.$FILE;
const RESO_PROP = "persist.sys.azenithconf.resosettings";
const executeCommand = async (cmd, cwd = null) => {
  try {
    const { errno, stdout, stderr } = await exec(cmd, cwd ? { cwd } : {});
    return { errno, stdout, stderr };
  } catch (e) {
    return { errno: -1, stdout: "", stderr: e.message || String(e) };
  }
};
window.executeCommand = executeCommand;


let pressTimer = null;
bannerBox.addEventListener("touchstart", () => {
  pressTimer = setTimeout(() => {
    bannerInput.click();
  }, 600);
});
bannerBox.addEventListener("touchend", () => clearTimeout(pressTimer));

// Touch / click gesture handling
const triggerFilePicker = (event: Event) => {
  event.preventDefault();
  bannerInput.value = ""; // reset previous selection
  bannerInput.click();
};

// Use touchend for long press if you want, or click for normal tap
bannerBox.addEventListener("click", triggerFilePicker);

// Banner file handling
bannerInput.addEventListener("change", async (event) => {
  const file = (event.target as HTMLInputElement).files?.[0];
  if (!file) return;

  bannerLoader.classList.add("show");
  toast(getTranslation("toast.chngeimg"));

  const img = new Image();
  img.src = URL.createObjectURL(file);

  img.onload = async () => {
    const targetRatio = 16 / 9;
    let srcW = img.width;
    let srcH = img.height;
    let cropW = srcW;
    let cropH = Math.floor(srcW / targetRatio);

    if (cropH > srcH) {
      cropH = srcH;
      cropW = Math.floor(srcH * targetRatio);
    }

    const startX = (srcW - cropW) / 2;
    const startY = (srcH - cropH) / 2;

    const outW = 1280;
    const outH = Math.floor(outW / targetRatio);

    const canvas = document.createElement("canvas");
    canvas.width = outW;
    canvas.height = outH;

    const ctx = canvas.getContext("2d")!;
    ctx.drawImage(img, startX, startY, cropW, cropH, 0, 0, outW, outH);

    canvas.toBlob(async (blob) => {
      if (!blob) {
        bannerLoader.classList.remove("show");
        return;
      }

      const reader = new FileReader();
      reader.onload = async () => {
        const base64 = reader.result!.toString().split(",")[1];

        const tmpFile = "/data/local/tmp/azenith_banner_tmp.b64";
        const outPath = "/data/local/tmp/azenith_banner_tmp.avif";

        await executeCommand(`rm -f "${tmpFile}" "${outPath}"`);

        const chunkSize = 16 * 1024; // 16 KB
        for (let i = 0; i < base64.length; i += chunkSize) {
          const chunk = base64.substring(i, i + chunkSize);
          await executeCommand(`echo -n "${chunk}" >> "${tmpFile}"`);
        }

        await executeCommand(`base64 -d "${tmpFile}" > "${outPath}"`);

        const dark = window.matchMedia("(prefers-color-scheme: dark)").matches;
        const targetFile = dark
          ? "/data/adb/modules/AZenith/webroot/webui.bannerdarkmode.avif"
          : "/data/adb/modules/AZenith/webroot/webui.bannerlightmode.avif";

        await executeCommand(`mv "${outPath}" "${targetFile}"`);
        updateBannerByTheme();
        await executeCommand(`rm -f "${tmpFile}"`);

        bannerLoader.classList.remove("show");
        toast(getTranslation("toast.imgsuccess"));
      };

      reader.readAsDataURL(blob);
    }, "image/avif");
  };
});

export const saveConfig = async () => {
  try {
    const config = await collectCurrentConfig();

    const timestamp = new Date()
      .toISOString()
      .replace(/[-:]/g, "")
      .replace("T", "-")
      .split(".")[0];

    const filename = `/sdcard/azenith-config-${timestamp}.json`;

    // Convert JSON to base64 so shell can write safely
    const jsonString = JSON.stringify(config, null, 2);
    const base64Data = btoa(jsonString);

    await executeCommand(
      `echo "${base64Data}" > "${filename}"`
    );

    console.log("Config saved to:", filename);
    const saveconfToast = getTranslation("toast.saveconf", filename);
    toast(saveconfToast);
    return true;
  } catch (err) {
    console.error("saveConfig failed:", err);
    return false;
  }
};

export const loadConfigFile = async (file) => {
  try {
    // Read base64 text
    const base64Text = (await file.text()).trim();

    // Decode base64 → JSON string
    let jsonText;
    try {
      jsonText = atob(base64Text);
    } catch (e) {
      throw new Error("Base64 decode failed");
    }

    // Parse JSON
    let config;
    try {
      config = JSON.parse(jsonText);
    } catch (e) {
      throw new Error("Invalid JSON structure");
    }

    const expectedKeys = {
      config: [
        "justintime","disabletrace","logd","DThermal","SFL","malisched","fpsged",
        "schedtunes","clearbg","bypasschg","APreload","iosched","cpulimit","dnd",
        "AIenabled","vsync","freqoffset","schemeconfig","scale","showtoast",
        "resosettings","preloadbudget","thermalcore"
      ],
      governors: ["custom_default_cpu_gov", "custom_powersave_cpu_gov"],
      io: ["custom_default_balanced_IO", "custom_powersave_IO", "custom_performance_IO"]
    };

    // Validate structure
    for (const section of Object.keys(expectedKeys)) {
      if (!config[section] || typeof config[section] !== "object") {
        throw new Error(`Missing or invalid section: ${section}`);
      }

      for (const key of expectedKeys[section]) {
        if (!(key in config[section])) {
          throw new Error(`Missing key '${key}' in section '${section}'`);
        }
      }
    }

    await applySavedConfig(config);

    const loadconfToast = getTranslation("toast.loadconf");
    toast(loadconfToast);
    return true;

  } catch (err) {
    console.error("loadConfigFile failed:", err);
    const loadconffailToast = getTranslation("toast.loadconffail");
    toast(loadconffailToast);
    return false;
  }
};

const collectCurrentConfig = async () => {
  const get = async (prop, fallback = "0") => {
    try {
      const out = await executeCommand(`getprop ${prop}`);
      return (out.stdout || "").trim() || fallback;
    } catch {
      return fallback;
    }
  };

  return {
       
    config: {
      justintime: await get("persist.sys.azenithconf.justintime"),
      disabletrace: await get("persist.sys.azenithconf.disabletrace"),
      logd: await get("persist.sys.azenithconf.logd"),
      DThermal: await get("persist.sys.azenithconf.DThermal"),
      SFL: await get("persist.sys.azenithconf.SFL"),
      malisched: await get("persist.sys.azenithconf.malisched"),
      fpsged: await get("persist.sys.azenithconf.fpsged"),
      schedtunes: await get("persist.sys.azenithconf.schedtunes"),
      clearbg: await get("persist.sys.azenithconf.clearbg"),
      bypasschg: await get("persist.sys.azenithconf.bypasschg"),
      APreload: await get("persist.sys.azenithconf.APreload"),
      iosched: await get("persist.sys.azenithconf.iosched"),
      cpulimit: await get("persist.sys.azenithconf.cpulimit"),
      dnd: await get("persist.sys.azenithconf.dnd"),
      AIenabled: await get("persist.sys.azenithconf.AIenabled"),
      vsync: await get("persist.sys.azenithconf.vsync"),
      freqoffset: await get("persist.sys.azenithconf.freqoffset"),
      schemeconfig: await get("persist.sys.azenithconf.schemeconfig"),
      scale: await get("persist.sys.azenithconf.scale"),
      showtoast: await get("persist.sys.azenithconf.showtoast"),
      resosettings: await get("persist.sys.azenithconf.resosettings"),
      preloadbudget: await get("persist.sys.azenithconf.preloadbudget"),
      thermalcore: await get("persist.sys.azenithconf.thermalcore"),
    },

    governors: {
      custom_default_cpu_gov: await get("persist.sys.azenith.custom_default_cpu_gov"),
      custom_powersave_cpu_gov: await get("persist.sys.azenith.custom_powersave_cpu_gov"),
    },

    io: {
      custom_default_balanced_IO: await get("persist.sys.azenith.custom_default_balanced_IO"),
      custom_powersave_IO: await get("persist.sys.azenith.custom_powersave_IO"),
      custom_performance_IO: await get("persist.sys.azenith.custom_performance_IO"),
    }
  };
};

const applySavedConfig = async (saved) => {
  if (!saved || typeof saved !== "object") return;

  const set = async (prop, value) => {
    if (value === undefined || value === null) return;
    try {
      await executeCommand(`setprop ${prop} "${value}"`);
    } catch (e) {
      console.error("Failed to set:", prop, value, e);
    }
  };

  if (saved.config) {
    await set("persist.sys.azenithconf.justintime", saved.config.justintime);
    await set("persist.sys.azenithconf.disabletrace", saved.config.disabletrace);
    await set("persist.sys.azenithconf.logd", saved.config.logd);
    await set("persist.sys.azenithconf.DThermal", saved.config.DThermal);
    await set("persist.sys.azenithconf.SFL", saved.config.SFL);
    await set("persist.sys.azenithconf.malisched", saved.config.malisched);
    await set("persist.sys.azenithconf.fpsged", saved.config.fpsged);
    await set("persist.sys.azenithconf.schedtunes", saved.config.schedtunes);
    await set("persist.sys.azenithconf.clearbg", saved.config.clearbg);
    await set("persist.sys.azenithconf.bypasschg", saved.config.bypasschg);
    await set("persist.sys.azenithconf.APreload", saved.config.APreload);
    await set("persist.sys.azenithconf.iosched", saved.config.iosched);
    await set("persist.sys.azenithconf.cpulimit", saved.config.cpulimit);
    await set("persist.sys.azenithconf.dnd", saved.config.dnd);
    await set("persist.sys.azenithconf.AIenabled", saved.config.AIenabled);
    await set("persist.sys.azenithconf.vsync", saved.config.vsync);
    await set("persist.sys.azenithconf.freqoffset", saved.config.freqoffset);
    await set("persist.sys.azenithconf.schemeconfig", saved.config.schemeconfig);
    await set("persist.sys.azenithconf.scale", saved.config.scale);
    await set("persist.sys.azenithconf.showtoast", saved.config.showtoast);
    await set("persist.sys.azenithconf.resosettings", saved.config.resosettings);
    await set("persist.sys.azenithconf.preloadbudget", saved.config.preloadbudget);
    await set("persist.sys.azenithconf.thermalcore", saved.config.thermalcore);
  }

  if (saved.governors) {
    await set("persist.sys.azenith.custom_default_cpu_gov", saved.governors.custom_default_cpu_gov);
    await set("persist.sys.azenith.custom_powersave_cpu_gov", saved.governors.custom_powersave_cpu_gov);
  }

  if (saved.io) {
    await set("persist.sys.azenith.custom_default_balanced_IO", saved.io.custom_default_balanced_IO);
    await set("persist.sys.azenith.custom_powersave_IO", saved.io.custom_powersave_IO);
    await set("persist.sys.azenith.custom_performance_IO", saved.io.custom_performance_IO);
  }
};

const showRandomMessage = () => {
  const c = document.getElementById("msg");
  if (!c) return;

  // Make sure currentTranslations exists
  if (!window.getTranslation) return;

  // Pick a random key from 0–29
  const randomIndex = Math.floor(Math.random() * 30);
  const message = window.getTranslation(`randomMessages.${randomIndex}`);

  if (message) {
    c.textContent = message;
  } else {
    c.textContent = ""; // fallback if translation not loaded
  }
};

let lastProfile = { time: 0, value: "" };
const checkProfile = async () => {
  const now = Date.now();
  if (now - lastProfile.time < 5000) return;

  try {
    const { errno: c, stdout: s } = await executeCommand(
      "cat /data/adb/.config/AZenith/API/current_profile"
    );

    if (c !== 0) return;
    const r = s.trim();
    const d = document.getElementById("CurProfile");
    if (!d) return;

    let l =
      { 0: "Initializing...", 1: "Performance", 2: "Balanced", 3: "ECO Mode" }[
        r
      ] || "Unknown";

    // Check for Lite mode
    const { errno: c2, stdout: s2 } = await executeCommand(
      "getprop persist.sys.azenithconf.cpulimit"
    );
    if (c2 === 0 && s2.trim() === "1") l += " (Lite)";

    if (lastProfile.value === l) return;
    lastProfile = { time: now, value: l };

    d.textContent = l;

    // Detect theme mode
    const isDark = window.matchMedia("(prefers-color-scheme: dark)").matches;

    // Dark mode colors (original) vs light mode (darker/saturated)
    const colors = isDark
      ? {
          Performance: "#ef4444",
          Balanced: "#7dd3fc",
          "ECO Mode": "#5eead4",
          "Initializing...": "#60a5fa",
          Default: "#ffffff",
        }
      : {
          Performance: "#b91c1c",
          Balanced: "#0284c7",
          "ECO Mode": "#0d9488",
          "Initializing...": "#2563eb",
          Default: "#1f2937",
        };

    const key = l.replace(" (Lite)", "");
    d.style.color = colors[key] || colors.Default;
  } catch (m) {
    console.error("checkProfile error:", m);
  }
};

let cachedSOCData = null;
const fetchSOCDatabase = async () => {
  if (!cachedSOCData) {
    try {
      cachedSOCData = await (await fetch("webui.soclist.json")).json();
    } catch {
      cachedSOCData = {};
    }
  }
  return cachedSOCData;
};

const getSoCModel = async () => {
  const props = [
    "ro.soc.model",
    "ro.hardware.chipname",
    "ro.board.platform",
    "ro.product.board",
    "ro.chipname",
    "ro.mediatek.platform",
  ];

  for (const prop of props) {
    const { errno, stdout } = await executeCommand(`getprop ${prop}`);
    if (errno === 0 && stdout.trim()) {
      return stdout.trim();
    }
  }

  return "Unknown SoC";
};

const checkCPUInfo = async () => {
  const cached = localStorage.getItem("soc_info");
  try {
    const rawModel = await getSoCModel();
    const model = rawModel.replace(/\s+/g, "");

    const db = await fetchSOCDatabase();
    let displayName = db[model];

    if (!displayName) {
      for (let i = model.length; i >= 6; i--) {
        const partial = model.substring(0, i);
        if (db[partial]) {
          displayName = db[partial];
          break;
        }
      }
    }

    if (!displayName) displayName = model;

    document.getElementById("cpuInfo").textContent = displayName;

    if (cached !== displayName) {
      localStorage.setItem("soc_info", displayName);
    }
  } catch {
    document.getElementById("cpuInfo").textContent = cached || "Error";
  }

  showFPSGEDIfMediatek();
  showMaliSchedIfMediatek();
  showBypassIfMTK();
  showThermalIfMTK();
};

const checkKernelVersion = async () => {
  let cachedKernel = localStorage.getItem("kernel_version");

  try {
    const { errno, stdout } = await executeCommand("uname -r");
    const el = document.getElementById("kernelInfo");

    if (errno === 0 && stdout.trim()) {
      const version = stdout.trim();
      el.textContent = version;

      if (cachedKernel !== version) {
        localStorage.setItem("kernel_version", version);
      }
    } else {
      el.textContent = cachedKernel || "Unknown Kernel";
    }
  } catch {
    el.textContent = cachedKernel || "Error";
  }
};

const getAndroidVersion = async () => {
  let cachedVersion = localStorage.getItem("android_version");

  try {
    const { errno, stdout } = await executeCommand("getprop ro.build.version.release");
    const el = document.getElementById("android");

    if (errno === 0 && stdout.trim()) {
      const version = stdout.trim();
      el.textContent = version;

      if (cachedVersion !== version) {
        localStorage.setItem("android_version", version);
      }
    } else {
      el.textContent = cachedVersion || "Unknown Android";
    }
  } catch {
    el.textContent = cachedVersion || "Error";
  }
};

let lastServiceCheck = { time: 0, status: "", pid: "" };

const checkServiceStatus = async () => {
  const now = Date.now();
  if (now - lastServiceCheck.time < 1000) return; // 1s throttle
  lastServiceCheck.time = now;

  const r = document.getElementById("serviceStatus");
  const d = document.getElementById("servicePID");
  if (!r || !d) return;

  try {
    // Get PID immediately
    const { errno: pidErr, stdout: pidOut } = await executeCommand(
      "/system/bin/toybox pidof sys.azenith-service"
    );

    let status = "";
    let pidText = getTranslation("serviceStatus.servicePID", "null");

    if (pidErr === 0 && pidOut.trim() !== "0") {
      const pid = pidOut.trim();
      pidText = getTranslation("serviceStatus.servicePID", pid);
      d.textContent = pidText; // show PID immediately

      // Fetch profile & AI in parallel without blocking PID display
      Promise.all([
        executeCommand("cat /data/adb/.config/AZenith/API/current_profile"),
        executeCommand("getprop persist.sys.azenithconf.AIenabled")
      ]).then(([profileRawResult, aiRawResult]) => {
        const profile = profileRawResult.stdout?.trim() || "";
        const ai = aiRawResult.stdout?.trim() || "";

        // Determine status
        if (profile === "0") status = getTranslation("serviceStatus.initializing");
        else if (["1", "2", "3"].includes(profile)) {
          status =
            ai === "1"
              ? getTranslation("serviceStatus.runningAuto")
              : ai === "0"
              ? getTranslation("serviceStatus.runningIdle")
              : getTranslation("serviceStatus.unknownProfile");
        } else status = getTranslation("serviceStatus.unknownProfile");

        if (lastServiceCheck.status !== status) r.textContent = status;
        lastServiceCheck.status = status;
      });
    } else {
      status = getTranslation("serviceStatus.suspended");
      d.textContent = pidText; // show null PID
      if (lastServiceCheck.status !== status) r.textContent = status;
      lastServiceCheck.status = status;
    }

    lastServiceCheck.pid = pidText;
  } catch (e) {
    console.warn("checkServiceStatus error:", e);
  }
};

const checkfpsged = async () => {
  let { errno: c, stdout: s } = await executeCommand(
    "getprop persist.sys.azenithconf.fpsged"
  );
  0 === c && (document.getElementById("fpsged").checked = "1" === s.trim());
};

const setfpsged = async (c) => {
  await executeCommand(
    c
      ? "setprop persist.sys.azenithconf.fpsged 1"
      : "setprop persist.sys.azenithconf.fpsged 0"
  );
};

const showFPSGEDIfMediatek = () => {
  const soc = (localStorage.getItem("soc_info") || "").toLowerCase();
  const fpsgedDiv = document.getElementById("fpsged-container");
  if (fpsgedDiv) {
    fpsgedDiv.style.display = soc.includes("mediatek") ? "flex" : "none";
  }
};

const checkDND = async () => {
  let { errno: c, stdout: s } = await executeCommand(
    "getprop persist.sys.azenithconf.dnd"
  );
  0 === c && (document.getElementById("DoNoDis").checked = "1" === s.trim());
};

const setDND = async (c) => {
  await executeCommand(
    c
      ? "setprop persist.sys.azenithconf.dnd 1"
      : "setprop persist.sys.azenithconf.dnd 0"
  );
};

const checkBypassChargeStatus = async () => {
  let { errno: c, stdout: s } = await executeCommand(
    "getprop persist.sys.azenithconf.bypasschg"
  );
  0 === c && (document.getElementById("Zepass").checked = "1" === s.trim());
};

const setBypassChargeStatus = async (c) => {
  await executeCommand(
    c
      ? "setprop persist.sys.azenithconf.bypasschg 1"
      : "setprop persist.sys.azenithconf.bypasschg 0"
  );
};
const showBypassIfMTK = () => {
  const soc = (localStorage.getItem("soc_info") || "").toLowerCase();
  const ZepassDiv = document.getElementById("Zepass-container");
  if (ZepassDiv) {
    ZepassDiv.style.display = soc.includes("mediatek") ? "flex" : "none";
  }
};

const checkLiteModeStatus = async () => {
  let { errno: c, stdout: s } = await executeCommand(
    "getprop persist.sys.azenithconf.cpulimit"
  );
  0 === c && (document.getElementById("LiteMode").checked = "1" === s.trim());
};

const setLiteModeStatus = async (c) => {
  await executeCommand(
    c
      ? "setprop persist.sys.azenithconf.cpulimit 1"
      : "setprop persist.sys.azenithconf.cpulimit 0"
  );
};

const checkDThermal = async () => {
  let { errno: c, stdout: s } = await executeCommand(
    "getprop persist.sys.azenithconf.DThermal"
  );
  0 === c && (document.getElementById("DThermal").checked = "1" === s.trim());
};

const setDThermal = async (c) => {
  await executeCommand(
    c
      ? "setprop persist.sys.azenithconf.DThermal 1"
      : "setprop persist.sys.azenithconf.DThermal 0"
  );
};

const showThermalIfMTK = () => {
  const soc = (localStorage.getItem("soc_info") || "").toLowerCase();
  const thermalDiv = document.getElementById("DThermal-container");
  if (thermalDiv) {
    thermalDiv.style.display = soc.includes("mediatek") ? "flex" : "none";
  }
};

const checkSFL = async () => {
  let { errno: c, stdout: s } = await executeCommand(
    "getprop persist.sys.azenithconf.SFL"
  );
  0 === c && (document.getElementById("SFL").checked = "1" === s.trim());
};

const setSFL = async (c) => {
  await executeCommand(
    c
      ? "setprop persist.sys.azenithconf.SFL 1"
      : "setprop persist.sys.azenithconf.SFL 0"
  );
};
const checkschedtunes = async () => {
  let { errno: c, stdout: s } = await executeCommand(
    "getprop persist.sys.azenithconf.schedtunes"
  );
  0 === c && (document.getElementById("schedtunes").checked = "1" === s.trim());
};

const setschedtunes = async (c) => {
  await executeCommand(
    c
      ? "setprop persist.sys.azenithconf.schedtunes 1"
      : "setprop persist.sys.azenithconf.schedtunes 0"
  );
};

const checkiosched = async () => {
  let { errno: c, stdout: s } = await executeCommand(
    "getprop persist.sys.azenithconf.iosched"
  );
  0 === c && (document.getElementById("iosched").checked = "1" === s.trim());
};

const setiosched = async (c) => {
  await executeCommand(
    c
      ? "setprop persist.sys.azenithconf.iosched 1"
      : "setprop persist.sys.azenithconf.iosched 0"
  );
};

const applyFSTRIM = async () => {
  await executeCommand(
    "/data/adb/modules/AZenith/system/bin/sys.azenith-utilityconf FSTrim"
  );
  const fstrimToast = getTranslation("toast.fstrim");
  toast(fstrimToast);
};

const setDefaultCpuGovernor = async (c) => {
  let s = "/data/adb/.config/AZenith",
    r = `${s}/API/current_profile`;
  await executeCommand(
    `setprop persist.sys.azenith.custom_default_cpu_gov ${c}`
  );
  let { errno: d, stdout: l } = await executeCommand(`cat ${r}`);
  0 === d &&
    "2" === l.trim() &&
    (await executeCommand(
      `/data/adb/modules/AZenith/system/bin/sys.azenith-utilityconf setsgov ${c}`
    ));
};

const loadCpuGovernors = async () => {
  let { errno: c, stdout: s } = await executeCommand(
    "chmod 644 /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_governors && cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_governors"
  );
  if (0 === c) {
    let r = s.trim().split(/\s+/),
      d = document.getElementById("cpuGovernor");
    d.innerHTML = "";
    r.forEach((c) => {
      let s = document.createElement("option");
      s.value = c;
      s.textContent = c;
      d.appendChild(s);
    });
    let { errno: l, stdout: m } = await executeCommand(
      `sh -c '[ -n "$(getprop persist.sys.azenith.custom_default_cpu_gov)" ] && getprop persist.sys.azenith.custom_default_cpu_gov || getprop persist.sys.azenith.default_cpu_gov'`
    );
    0 === l && (d.value = m.trim());
  }
};

const setGovernorPowersave = async (c) => {
  let s = "/data/adb/.config/AZenith",
    r = `${s}/API/current_profile`;
  await executeCommand(
    `setprop persist.sys.azenith.custom_powersave_cpu_gov ${c}`
  );
  let { errno: d, stdout: l } = await executeCommand(`cat ${r}`);
  0 === d &&
    "3" === l.trim() &&
    (await executeCommand(
      `/data/adb/modules/AZenith/system/bin/sys.azenith-utilityconf setsgov ${c}`
    ));
};

const GovernorPowersave = async () => {
  let { errno: c, stdout: s } = await executeCommand(
    "chmod 644 /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_governors && cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_governors"
  );
  if (0 === c) {
    let r = s.trim().split(/\s+/),
      d = document.getElementById("GovernorPowersave");
    d.innerHTML = "";
    r.forEach((c) => {
      let s = document.createElement("option");
      s.value = c;
      s.textContent = c;
      d.appendChild(s);
    });
    let { errno: l, stdout: m } = await executeCommand(
      `sh -c '[ -n "$(getprop persist.sys.azenith.custom_powersave_cpu_gov)" ] && getprop persist.sys.azenith.custom_powersave_cpu_gov'`
    );
    0 === l && (d.value = m.trim());
  }
};

const hideGameListModal = () => {
  let c = document.getElementById("gamelistModal");
  c.classList.remove("show");
  document.body.classList.remove("modal-open");
  c._resizeHandler &&
    (window.removeEventListener("resize", c._resizeHandler),
    delete c._resizeHandler);
};

let originalGamelist = "";

const showGameListModal = async () => {
  let { errno: c, stdout: s } = await executeCommand(
    "getprop persist.sys.azenithconf.AIenabled"
  );
  if (0 === c && "0" === s.trim()) {
    const showCantAccessToast = getTranslation("toast.showcantaccess");
    toast(showCantAccessToast);
    return;
  }

  const r = document.getElementById("gamelistModal");
  const d = document.getElementById("gamelistInput");
  const searchInput = document.getElementById("gamelistSearch");
  const l = r.querySelector(".gamelist-content");

  const { errno: m, stdout: h } = await executeCommand(
    "cat /data/adb/.config/AZenith/gamelist/gamelist.txt"
  );

  if (m === 0) {
    const formatted = h.trim().replace(/\|/g, "\n");
    originalGamelist = formatted;
    d.value = formatted;
  }

  if (searchInput) {
    searchInput.value = "";
    searchInput.removeEventListener("input", filterGameList);
    searchInput.addEventListener("input", filterGameList);
  }

  r.classList.add("show");
  document.body.classList.add("modal-open");
  setTimeout(() => d.focus(), 100);

  const g = window.innerHeight;
  const f = () => {
    window.innerHeight < g - 150
      ? (l.style.transform = "translateY(-10%) scale(1)")
      : (l.style.transform = "translateY(0) scale(1)");
  };

  window.addEventListener("resize", f, { passive: true });
  r._resizeHandler = f;
  f();
};

const filterGameList = () => {
  const searchTerm = document
    .getElementById("gamelistSearch")
    .value.toLowerCase();
  const gamelistInput = document.getElementById("gamelistInput");

  if (!searchTerm) {
    gamelistInput.value = originalGamelist;
    return;
  }

  const filteredList = originalGamelist
    .split("\n")
    .filter((line) => line.toLowerCase().includes(searchTerm))
    .join("\n");

  gamelistInput.value = filteredList;
};

const saveGameList = async () => {
  const gamelistInput = document.getElementById("gamelistInput");
  const searchInput = document.getElementById("gamelistSearch");
  const searchTerm = (searchInput?.value || "").toLowerCase();

  const editedLines = gamelistInput.value
    .split("\n")
    .map((x) => x.trim())
    .filter(Boolean);

  const originalLines = originalGamelist
    .split("\n")
    .map((x) => x.trim())
    .filter(Boolean);

  if (!searchTerm) {
    const outputString = editedLines.join("|").replace(/"/g, '\\"');
    await executeCommand(
      `echo "${outputString}" > /data/adb/.config/AZenith/gamelist/gamelist.txt`
    );
    const savedPackagesToast = getTranslation("toast.savedPackages", editedLines.length);
    toast(savedPackagesToast);
    hideGameListModal();
    return;
  }

  let editedIndex = 0;
  const mergedLines = originalLines.map((line) => {
    if (line.toLowerCase().includes(searchTerm)) {
      const replacement = editedLines[editedIndex++]?.trim();
      return replacement || line;
    }
    return line;
  });

  const outputString = mergedLines.join("|").replace(/"/g, '\\"');
  await executeCommand(
    `echo "${outputString}" > /data/adb/.config/AZenith/gamelist/gamelist.txt`
  );
  const savedPackagesToast = getTranslation("toast.savedPackages", mergedLines.length);
  toast(savedPackagesToast);
  hideGameListModal();
};
const checklogger = async () => {
  let { errno: c, stdout: s } = await executeCommand(
    "getprop persist.sys.azenith.debugmode"
  );
  0 === c && (document.getElementById("logger").checked = "true" === s.trim());
};

const setlogger = async (c) => {
  await executeCommand(
    c
      ? "setprop persist.sys.azenith.debugmode true"
      : "setprop persist.sys.azenith.debugmode false"
  );
};

const setVsyncValue = async (c) => {
  await executeCommand(`setprop persist.sys.azenithconf.vsync ${c}`);
  await executeCommand(
    `/data/adb/modules/AZenith/system/bin/sys.azenith-utilityconf disablevsync ${c}`
  );
};

const loadVsyncValue = async () => {
  let { errno: c, stdout: s } = await executeCommand(
    "getprop persist.sys.azenithdebug.vsynclist"
  );
  if (0 === c) {
    let r = s.trim().split(/\s+/),
      d = document.getElementById("disablevsync");
    (d.innerHTML = ""),
      r.forEach((c) => {
        let s = document.createElement("option");
        (s.value = c), (s.textContent = c), d.appendChild(s);
      });
    let { errno: l, stdout: m } = await executeCommand(
      `sh -c '[ -n "$(getprop persist.sys.azenithconf.vsync)" ] && getprop persist.sys.azenithconf.vsync'`
    );
    0 === l && (d.value = m.trim());
  }
};

const setCpuFreqOffsets = async (c) => {
  let s = "/data/adb/.config/AZenith",
    r = `${s}/API/current_profile`;
  await executeCommand(`setprop persist.sys.azenithconf.freqoffset ${c}`);
  let { errno: d, stdout: l } = await executeCommand(`cat ${r}`);
  if (d === 0) {
    let profile = l.trim();
    if (profile === "2" || profile === "3") {
      await executeCommand(
        `/data/adb/modules/AZenith/system/bin/sys.azenith-utilityconf setsfreqs`
      );
    }
  }
};

const loadCpuFreq = async () => {
  let { errno: c, stdout: s } = await executeCommand(
    "getprop persist.sys.azenithdebug.freqlist"
  );
  if (0 === c) {
    let r = s.trim().split(/\s+/),
      d = document.getElementById("cpuFreq");
    (d.innerHTML = ""),
      r.forEach((c) => {
        let s = document.createElement("option");
        (s.value = c), (s.textContent = c), d.appendChild(s);
      });
    let { errno: l, stdout: m } = await executeCommand(
      `sh -c '[ -n "$(getprop persist.sys.azenithconf.freqoffset)" ] && getprop persist.sys.azenithconf.freqoffset'`
    );
    0 === l && (d.value = m.trim());
  }
};
const checkKillLog = async () => {
  let { errno: c, stdout: s } = await executeCommand(
    "getprop persist.sys.azenithconf.logd"
  );
  0 === c && (document.getElementById("logd").checked = "1" === s.trim());
};

const setKillLog = async (c) => {
  await executeCommand(
    c
      ? "setprop persist.sys.azenithconf.logd 1"
      : "setprop persist.sys.azenithconf.logd 0"
  );
};

const startService = async () => {
  try {
    let { stdout: c } = await executeCommand(
      "cat /data/adb/.config/AZenith/API/current_profile"
    );
    let s = c.trim();

    if (s === "0") {
      const cantRestartToast = getTranslation("toast.cantRestart");
      toast(cantRestartToast);
      return;
    }

    let { stdout: pid } = await executeCommand(
      "/system/bin/toybox pidof sys.azenith-service"
    );
    if (!pid || pid.trim() === "") {
      const serviceDeadToast = getTranslation("toast.serviceDead");
      toast(serviceDeadToast);
      return;
    }

    const restartingDaemonToast = getTranslation("toast.restartingDaemon");
    toast(restartingDaemonToast);
    
    await executeCommand(
      "pkill -9 -f sys.azenith.rianixiathermalcorev4"
    );
    await executeCommand(
      "setprop persist.sys.azenith.state stopped && pkill -9 -f sys.azenith-service; su -c '/data/adb/modules/AZenith/system/bin/sys.azenith-service > /dev/null 2>&1 & disown'"
    );

    await checkServiceStatus();
  } catch (r) {
    const restartFailedToast = getTranslation("toast.restartFailed");
    toast(restartFailedToast);
    console.error("startService error:", r);
  }
};

const checkGPreload = async () => {
  let { errno: c, stdout: s } = await executeCommand(
    "getprop persist.sys.azenithconf.APreload"
  );
  0 === c && (document.getElementById("GPreload").checked = "1" === s.trim());
};

const setGPreloadStatus = async (c) => {
  await executeCommand(
    c
      ? "setprop persist.sys.azenithconf.APreload 1"
      : "setprop persist.sys.azenithconf.APreload 0"
  );
};
const checkRamBoost = async () => {
  let { errno: c, stdout: s } = await executeCommand(
    "getprop persist.sys.azenithconf.clearbg"
  );
  0 === c && (document.getElementById("clearbg").checked = "1" === s.trim());
};

const setRamBoostStatus = async (c) => {
  await executeCommand(
    c
      ? "setprop persist.sys.azenithconf.clearbg 1"
      : "setprop persist.sys.azenithconf.clearbg 0"
  );
};

const checkmalisched = async () => {
  let { errno: c, stdout: s } = await executeCommand(
    "getprop persist.sys.azenithconf.malisched"
  );
  0 === c && (document.getElementById("malisched").checked = "1" === s.trim());
};

const setmalisched = async (c) => {
  await executeCommand(
    c
      ? "setprop persist.sys.azenithconf.malisched 1"
      : "setprop persist.sys.azenithconf.malisched 0"
  );
};

const showMaliSchedIfMediatek = () => {
  const soc = (localStorage.getItem("soc_info") || "").toLowerCase();
  const MaliSchedDiv = document.getElementById("malisched-container");
  if (MaliSchedDiv) {
    MaliSchedDiv.style.display = soc.includes("mediatek") ? "flex" : "none";
  }
};

const showColorScheme = async () => {
  const c = document.getElementById("schemeModal");
  if (!c) return; // Modal element not found

  const s = c.querySelector(".scheme-container");
  if (!s) return; // Modal content not found

  document.body.classList.add("modal-open");
  c.classList.add("show");

  const originalHeight = window.innerHeight;

  const resizeHandler = () => {
    if (!s) return;
    window.innerHeight < originalHeight - 150
      ? (s.style.transform = "translateY(-10%) scale(1)")
      : (s.style.transform = "translateY(0) scale(1)");
  };

  window.addEventListener("resize", resizeHandler, { passive: true });
  c._resizeHandler = resizeHandler;

  resizeHandler();
};

const hidecolorscheme = () => {
  const c = document.getElementById("schemeModal");
  if (!c) return; // exit if modal not found

  c.classList.remove("show");
  document.body.classList.remove("modal-open");
  const colorSchemeSavedToast = getTranslation("toast.colorSchemeSaved");
  toast(colorSchemeSavedToast);

  if (c._resizeHandler) {
    window.removeEventListener("resize", c._resizeHandler);
    delete c._resizeHandler;
  }
};

const saveDisplaySettings = (c, s, r, d) => {
  const cmd = `sh -c 'setprop persist.sys.azenithconf.schemeconfig "${c} ${s} ${r} ${d}"'`;
  executeCommand(cmd);
};

const loadDisplaySettings = async () => {
  try {
    const c = await executeCommand(
      `sh -c "getprop persist.sys.azenithconf.schemeconfig"`
    );
    const [s, r, d, l] = (
      typeof c === "object" && c.stdout ? c.stdout.trim() : String(c).trim()
    )
      .split(/\s+/)
      .map(Number);

    if ([s, r, d, l].some(isNaN)) {
      const invalidColorSchemeToast = getTranslation("toast.invalidColorScheme");
      toast(invalidColorSchemeToast);
      return { red: 1000, green: 1000, blue: 1000, saturation: 1000 };
    }

    return { red: s, green: r, blue: d, saturation: l };
  } catch (m) {
    console.log("Error reading display settings:", m);
    const colorSchemeNotFoundToast = getTranslation("toast.colorSchemeNotFound");
    toast(colorSchemeNotFoundToast);
    return { red: 1000, green: 1000, blue: 1000, saturation: 1000 };
  }
};

const setRGB = async (c, s, r) => {
  await executeCommand(
    `service call SurfaceFlinger 1015 i32 1 f ${c / 1000} f 0 f 0 f 0 f 0 f ${
      s / 1000
    } f 0 f 0 f 0 f 0 f ${r / 1000} f 0 f 0 f 0 f 0 f 1`
  );
};

const setSaturation = async (c) => {
  await executeCommand(`service call SurfaceFlinger 1022 f ${c / 1000}`);
};

const resetDisplaySettings = async () => {
  await executeCommand(
    "service call SurfaceFlinger 1015 i32 1 f 1 f 0 f 0 f 0 f 0 f 1 f 0 f 0 f 0 f 0 f 1 f 0 f 0 f 0 f 0 f 1"
  );
  await executeCommand("service call SurfaceFlinger 1022 f 1");
  saveDisplaySettings(1000, 1000, 1000, 1000);
  document.getElementById("red").value = 1000;
  document.getElementById("green").value = 1000;
  document.getElementById("blue").value = 1000;
  document.getElementById("saturation").value = 1000;
  const displayResetToast = getTranslation("toast.displayReset");
  toast(displayResetToast);
};
const checkAI = async () => {
  let { errno: c, stdout: s } = await executeCommand(
    "getprop persist.sys.azenithconf.AIenabled"
  );
  0 === c && (document.getElementById("disableai").checked = "0" === s.trim());
};

const setAI = async (c) => {
  await executeCommand(
    c
      ? "setprop persist.sys.azenithconf.AIenabled 0"
      : "setprop persist.sys.azenithconf.AIenabled 1"
  );
  await executeCommand(
    c
      ? "mv /data/adb/.config/AZenith/gamelist/gamelist.txt /data/adb/.config/AZenith/gamelist/gamelist.bin"
      : "mv /data/adb/.config/AZenith/gamelist/gamelist.bin /data/adb/.config/AZenith/gamelist/gamelist.txt"
  );
};

const getSu = async () => {
  const locations = [
    "/data/adb/ksu/bin/su",
    "/data/adb/ap/bin/su",
    "/system/bin/su",
    "/system/xbin/su",
    "su"
  ];

  for (const su of locations) {
    const { errno } = await executeCommand(`ls ${su}`);
    if (errno === 0) return su;
  }
  return null;
};

const runAsRoot = async (cmd) => {
  const su = await getSu();
  if (!su) {
    toast("Root not found");
    return;
  }
  return executeCommand(`${su} -c "${cmd}" >/dev/null 2>&1 &`);
};

const applyperformanceprofile = async () => {
  let { stdout: c } = await executeCommand(
    "cat /data/adb/.config/AZenith/API/current_profile"
  );
  if (c.trim() === "1") {
    toast(getTranslation("toast.alreadyPerformance"));
    return;
  }
  await runAsRoot("sys.azenith-profiler 1");
};

const applybalancedprofile = async () => {
  let { stdout: c } = await executeCommand(
    "cat /data/adb/.config/AZenith/API/current_profile"
  );
  if (c.trim() === "2") {
    toast(getTranslation("toast.alreadyBalanced"));
    return;
  }
  await runAsRoot("sys.azenith-profiler 2");
};

const applyecomode = async () => {
  let { stdout: c } = await executeCommand(
    "cat /data/adb/.config/AZenith/API/current_profile"
  );
  if (c.trim() === "3") {
    toast(getTranslation("toast.alreadyECO"));
    return;
  }
  await runAsRoot("sys.azenith-profiler 3");
};

const checkjit = async () => {
  let { errno: c, stdout: s } = await executeCommand(
    "getprop persist.sys.azenithconf.justintime"
  );
  0 === c && (document.getElementById("jit").checked = "1" === s.trim());
};

const setjit = async (c) => {
  await executeCommand(
    c
      ? "setprop persist.sys.azenithconf.justintime 1"
      : "setprop persist.sys.azenithconf.justintime 0"
  );
};

const checkdtrace = async () => {
  let { errno: c, stdout: s } = await executeCommand(
    "getprop persist.sys.azenithconf.disabletrace"
  );
  0 === c && (document.getElementById("trace").checked = "1" === s.trim());
};

const setdtrace = async (c) => {
  await executeCommand(
    c
      ? "setprop persist.sys.azenithconf.disabletrace 1"
      : "setprop persist.sys.azenithconf.disabletrace 0"
  );
};

const checktoast = async () => {
  let { errno: c, stdout: s } = await executeCommand(
    "getprop persist.sys.azenithconf.showtoast"
  );
  0 === c && (document.getElementById("toast").checked = "1" === s.trim());
};

const settoast = async (c) => {
  await executeCommand(
    c
      ? "setprop persist.sys.azenithconf.showtoast 1"
      : "setprop persist.sys.azenithconf.showtoast 0"
  );
};

const setIObalance = async (c) => {
  let s = "/data/adb/.config/AZenith",
    r = `${s}/API/current_profile`;
  await executeCommand(
    `setprop persist.sys.azenith.custom_default_balanced_IO ${c}`
  );
  let { errno: d, stdout: l } = await executeCommand(`cat ${r}`);
  0 === d &&
    "2" === l.trim() &&
    (await executeCommand(
      `/data/adb/modules/AZenith/system/bin/sys.azenith-utilityconf setsIO ${c}`
    ));
};

const loadIObalance = async () => {
  // Candidate block devices
  const blocks = ["mmcblk0", "mmcblk1", "sda", "sdb", "sdc"];
  let validBlock = null;

  // Find the first block that exists and has a scheduler file
  for (const blk of blocks) {
    const { errno } = await executeCommand(`test -e /sys/block/${blk}/queue/scheduler`);
    if (errno === 0) {
      validBlock = blk;
      break;
    }
  }

  if (!validBlock) {
    console.warn("No valid block device with scheduler found");
    return;
  }

  // Read scheduler list from detected block
  const { errno: c, stdout: s } = await executeCommand(`cat /sys/block/${validBlock}/queue/scheduler`);
  if (c !== 0) {
    console.warn("Failed to read scheduler from", validBlock);
    return;
  }

  // Populate select element
  const select = document.getElementById("ioSchedulerBalanced");
  if (!select) return;
  select.innerHTML = "";

  const schedulers = s.trim().split(/\s+/).map(sch => sch.replace(/[\[\]]/g, ""));
  schedulers.forEach(sch => {
    const opt = document.createElement("option");
    opt.value = sch;
    opt.textContent = sch;
    select.appendChild(opt);
  });

  // Get currently active/custom scheduler property
  const { errno: l, stdout: m } = await executeCommand(
    `sh -c '[ -n "$(getprop persist.sys.azenith.custom_default_balanced_IO)" ] && getprop persist.sys.azenith.custom_default_balanced_IO || getprop persist.sys.azenith.default_balanced_IO'`
  );

  if (l === 0) {
    const current = m.trim().replace(/[\[\]]/g, "");
    select.value = current;
  }

  console.log(`Detected block device: ${validBlock}`);
};

const setIOperformance = async (c) => {
  let s = "/data/adb/.config/AZenith",
    r = `${s}/API/current_profile`;
  await executeCommand(
    `setprop persist.sys.azenith.custom_performance_IO ${c}`
  );
  let { errno: d, stdout: l } = await executeCommand(`cat ${r}`);
  0 === d &&
    "1" === l.trim() &&
    (await executeCommand(
      `/data/adb/modules/AZenith/system/bin/sys.azenith-utilityconf setsIO ${c}`
    ));
};

const loadIOperformance = async () => {
  // Candidate block devices
  const blocks = ["mmcblk0", "mmcblk1", "sda", "sdb", "sdc"];
  let validBlock = null;

  // Find the first block device that has a scheduler file
  for (const blk of blocks) {
    const { errno } = await executeCommand(`test -e /sys/block/${blk}/queue/scheduler`);
    if (errno === 0) {
      validBlock = blk;
      break;
    }
  }

  if (!validBlock) {
    console.warn("No valid block device with scheduler found");
    return;
  }

  // Read available schedulers
  const { errno: c, stdout: s } = await executeCommand(`cat /sys/block/${validBlock}/queue/scheduler`);
  if (c !== 0) {
    console.warn(`Failed to read scheduler from /sys/block/${validBlock}`);
    return;
  }

  // Populate <select> options
  const select = document.getElementById("ioSchedulerPerformance");
  if (!select) return;
  select.innerHTML = "";

  const schedulers = s.trim().split(/\s+/).map(x => x.replace(/[\[\]]/g, ""));
  schedulers.forEach(sch => {
    const opt = document.createElement("option");
    opt.value = sch;
    opt.textContent = sch;
    select.appendChild(opt);
  });

  // Get current scheduler (custom performance property)
  const { errno: l, stdout: m } = await executeCommand(
    `sh -c '[ -n "$(getprop persist.sys.azenith.custom_performance_IO)" ] && getprop persist.sys.azenith.custom_performance_IO || echo ""'`
  );

  if (l === 0) {
    const current = m.trim().replace(/[\[\]]/g, "");
    if (current) select.value = current;
  }

  console.log(`Detected block device: ${validBlock}`);
};

const setIOpowersave = async (c) => {
  const s = "/data/adb/.config/AZenith",
    r = `${s}/API/current_profile`;
  await executeCommand(`setprop persist.sys.azenith.custom_powersave_IO ${c}`);
  const { errno: d, stdout: l } = await executeCommand(`cat ${r}`);
  if (d === 0 && l.trim() === "3") {
    await executeCommand(
      `/data/adb/modules/AZenith/system/bin/sys.azenith-utilityconf setsIO ${c}`
    );
  }
};

const loadIOpowersave = async () => {
  // Candidate block devices
  const blocks = ["mmcblk0", "mmcblk1", "sda", "sdb", "sdc"];
  let validBlock = null;

  // Find first block device that has a scheduler file
  for (const blk of blocks) {
    const { errno } = await executeCommand(`test -e /sys/block/${blk}/queue/scheduler`);
    if (errno === 0) {
      validBlock = blk;
      break;
    }
  }

  if (!validBlock) {
    console.warn("No valid block device with scheduler found");
    return;
  }

  // Read available schedulers
  const { errno: c, stdout: s } = await executeCommand(`cat /sys/block/${validBlock}/queue/scheduler`);
  if (c !== 0) {
    console.warn(`Failed to read scheduler from /sys/block/${validBlock}`);
    return;
  }

  // Populate dropdown
  const select = document.getElementById("ioSchedulerPowersave");
  if (!select) return;
  select.innerHTML = "";

  const schedulers = s.trim().split(/\s+/).map(x => x.replace(/[\[\]]/g, ""));
  schedulers.forEach(sch => {
    const opt = document.createElement("option");
    opt.value = sch;
    opt.textContent = sch;
    select.appendChild(opt);
  });

  // Get current scheduler (custom powersave property)
  const { errno: l, stdout: m } = await executeCommand(
    `sh -c '[ -n "$(getprop persist.sys.azenith.custom_powersave_IO)" ] && getprop persist.sys.azenith.custom_powersave_IO || echo ""'`
  );

  if (l === 0) {
    const current = m.trim().replace(/[\[\]]/g, "");
    if (current) select.value = current;
  }

  console.log(`Detected block device for powersave: ${validBlock}`);
};

const showAdditionalSettings = async () => {
  const c = document.getElementById("additional-modal"),
    s = c.querySelector(".additional-container");
  document.body.classList.add("modal-open");
  c.classList.add("show");

  const r = window.innerHeight;
  const d = () => {
    s.style.transform =
      window.innerHeight < r - 150
        ? "translateY(-10%) scale(1)"
        : "translateY(0) scale(1)";
  };
  window.addEventListener("resize", d, { passive: true });
  c._resizeHandler = d;
  d();
};

const hideAdditionalSettings = () => {
  const c = document.getElementById("additional-modal");
  c.classList.remove("show");
  document.body.classList.remove("modal-open");
  if (c._resizeHandler) {
    window.removeEventListener("resize", c._resizeHandler);
    delete c._resizeHandler;
  }
};

const showPreferenceSettings = async () => {
  const c = document.getElementById("preference-modal"),
    s = c.querySelector(".preference-container");
  document.body.classList.add("modal-open");
  c.classList.add("show");

  const r = window.innerHeight;
  const d = () => {
    s.style.transform =
      window.innerHeight < r - 150
        ? "translateY(-10%) scale(1)"
        : "translateY(0) scale(1)";
  };
  window.addEventListener("resize", d, { passive: true });
  c._resizeHandler = d;
  d();
};

const hidePreferenceSettings = () => {
  const c = document.getElementById("preference-modal");
  c.classList.remove("show");
  document.body.classList.remove("modal-open");
  if (c._resizeHandler) {
    window.removeEventListener("resize", c._resizeHandler);
    delete c._resizeHandler;
  }
};

const hideGamelistSettings = () => {
  const c = document.getElementById("gamelistModal");
  c.classList.remove("show");
  document.body.classList.remove("modal-open");
  if (c._resizeHandler) {
    window.removeEventListener("resize", c._resizeHandler);
    delete c._resizeHandler;
  }
};

const hideSchemeSettings = () => {
  const c = document.getElementById("schemeModal");
  c.classList.remove("show");
  document.body.classList.remove("modal-open");
  if (c._resizeHandler) {
    window.removeEventListener("resize", c._resizeHandler);
    delete c._resizeHandler;
  }
};

const savelog = async () => {
  try {
    await executeCommand(
      "/data/adb/modules/AZenith/system/bin/sys.azenith-utilityconf saveLog"
    );
    const logSavedMsg = getTranslation("toast.logSaved");
    toast(logSavedMsg);
  } catch (e) {
    const logSaveFailedMsg = getTranslation("toast.logSaveFailed");
    toast(logSaveFailedMsg);
    console.error("saveLog error:", e);
  }
};

const currentColor = {
  red: 1000,
  green: 1000,
  blue: 1000,
  saturation: 1000,
};

const debounce = (fn, delay = 200) => {
  let timer;
  return (...args) => {
    clearTimeout(timer);
    timer = setTimeout(() => fn(...args), delay);
  };
};

const updateColorState = ({ red, green, blue, saturation }) => {
  if (
    red !== currentColor.red ||
    green !== currentColor.green ||
    blue !== currentColor.blue ||
    saturation !== currentColor.saturation
  ) {
    currentColor.red = red;
    currentColor.green = green;
    currentColor.blue = blue;
    currentColor.saturation = saturation;

    saveDisplaySettings(red, green, blue, saturation);
    setRGB(red, green, blue);
    setSaturation(saturation);
  }
};

const loadColorSchemeSettings = async () => {
  const c = document.getElementById("red"),
    s = document.getElementById("green"),
    r = document.getElementById("blue"),
    d = document.getElementById("saturation"),
    l = document.getElementById("reset-btn"),
    cv = document.getElementById("red-value"),
    sv = document.getElementById("green-value"),
    rv = document.getElementById("blue-value"),
    dv = document.getElementById("saturation-value"),
    m = await loadDisplaySettings();

  // Update slider and number inputs
  [c, s, r, d].forEach((el, i) => {
    switch (i) {
      case 0:
        el.value = m.red;
        cv.value = m.red;
        break;
      case 1:
        el.value = m.green;
        sv.value = m.green;
        break;
      case 2:
        el.value = m.blue;
        rv.value = m.blue;
        break;
      case 3:
        el.value = m.saturation;
        dv.value = m.saturation;
        break;
    }
  });

  currentColor.red = m.red;
  currentColor.green = m.green;
  currentColor.blue = m.blue;
  currentColor.saturation = m.saturation;

  await setRGB(m.red, m.green, m.blue);
  await setSaturation(m.saturation);

  const handleInputChange = debounce(() => {
    cv.value = c.value;
    sv.value = s.value;
    rv.value = r.value;
    dv.value = d.value;

    updateColorState({
      red: Number(c.value),
      green: Number(s.value),
      blue: Number(r.value),
      saturation: Number(d.value),
    });
  }, 100);

  [c, s, r, d].forEach((el) => el.addEventListener("input", handleInputChange));

  const bindInput = (numberInput, slider, min, max) => {
    numberInput.addEventListener("input", () => {
      if (numberInput.value === "") return;
      slider.value = numberInput.value;
      handleInputChange();
    });

    const finalize = () => {
      if (numberInput.value === "") numberInput.value = slider.value;
      let v = Number(numberInput.value);
      if (isNaN(v)) v = min;
      if (v < min) v = min;
      if (v > max) v = max;
      numberInput.value = v;
      slider.value = v;
      handleInputChange();
    };

    numberInput.addEventListener("blur", finalize);
    numberInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") numberInput.blur();
    });
  };

  bindInput(cv, c, 0, 1000);
  bindInput(sv, s, 0, 1000);
  bindInput(rv, r, 0, 1000);
  bindInput(dv, d, 0, 2000);

  l.addEventListener("click", async () => {
    c.value = s.value = r.value = d.value = 1000;
    cv.value = sv.value = rv.value = dv.value = 1000;

    await setRGB(1000, 1000, 1000);
    await setSaturation(1000);

    currentColor.red = 1000;
    currentColor.green = 1000;
    currentColor.blue = 1000;
    currentColor.saturation = 1000;

    saveDisplaySettings(1000, 1000, 1000, 1000);
    const displayResetMsg = getTranslation("toast.displayReset");
    toast(displayResetMsg);
  });
};

const detectResolution = async () => {
  const { errno, stdout } = await executeCommand(
    `wm size | grep -oE "[0-9]+x[0-9]+" | head -n 1`
  );
  if (errno !== 0 || !stdout.trim()) {
    console.error("Failed to detect resolution");
    const unableDetectResMsg = getTranslation("toast.unableDetectResolution");
    toast(unableDetectResMsg);
    return;
  }

  const defaultRes = stdout.trim();
  const [width, height] = defaultRes.split("x").map(Number);
  if (!width || !height) return;

  const mediumRes = `${Math.round(width * 0.9)}x${Math.round(height * 0.9)}`;
  const lowRes = `${Math.round(width * 0.8)}x${Math.round(height * 0.8)}`;

  const resoSizes = document.querySelectorAll(".reso-size");
  if (resoSizes.length === 3) {
    resoSizes[0].textContent = lowRes;
    resoSizes[1].textContent = mediumRes;
    resoSizes[2].textContent = defaultRes;
  }

  window._reso = {
    default: defaultRes,
    medium: mediumRes,
    low: lowRes,
    selected: defaultRes,
  };

  const { stdout: saved } = await executeCommand(`getprop ${RESO_PROP}`);
  const savedRes = saved.trim();

  if (savedRes) {
    const buttons = document.querySelectorAll(".reso-option");
    buttons.forEach((btn) => {
      const text = btn.querySelector(".reso-size")?.textContent;
      if (text === savedRes) btn.classList.add("active");
      else btn.classList.remove("active");
    });
    if (window._reso) window._reso.selected = savedRes;
  } else {
    document.querySelectorAll(".reso-option")[2]?.classList.add("active");
  }
};

const selectResolution = async (btn) => {
  document
    .querySelectorAll(".reso-option")
    .forEach((b) => b.classList.remove("active"));
  btn.classList.add("active");

  const selectedText = btn.querySelector(".reso-size")?.textContent;
  if (!selectedText) return;

  if (window._reso) window._reso.selected = selectedText;
};

const applyResolution = async () => {
  if (!window._reso || !window._reso.selected) {
    const noResolutionSelected = getTranslation("toast.noResolutionSelected");
    toast(noResolutionSelected);
    return;
  }

  const selected = window._reso.selected;
  const def = window._reso.default;

  if (selected === def) {
    await executeCommand(`setprop ${RESO_PROP} ${selected}`);
    await executeCommand("wm size reset");
  } else {
    await executeCommand(`setprop ${RESO_PROP} ${selected}`);
    await executeCommand(`wm size ${selected}`);
  }
};

const showCustomResolution = async () => {
  const c = document.getElementById("resomodal");
  if (!c) return; // exit if modal not found

  const s = c.querySelector(".reso-container");
  if (!s) return;

  document.body.classList.add("modal-open");
  c.classList.add("show");

  await detectResolution();

  const r = window.innerHeight;
  const d = () => {
    window.innerHeight < r - 150
      ? (s.style.transform = "translateY(-10%) scale(1)")
      : (s.style.transform = "translateY(0) scale(1)");
  };

  window.addEventListener("resize", d, { passive: true });
  c._resizeHandler = d;
  d();
};

const hideResoSettings = () => {
  const c = document.getElementById("resomodal");
  c.classList.remove("show");
  document.body.classList.remove("modal-open");
  if (c._resizeHandler) {
    window.removeEventListener("resize", c._resizeHandler);
    delete c._resizeHandler;
  }
};

const showSettings = async () => {
  const c = document.getElementById("settingsModal"),
    s = c.querySelector(".settings-container");
  document.body.classList.add("modal-open");
  c.classList.add("show");

  const r = window.innerHeight;
  const d = () => {
    s.style.transform =
      window.innerHeight < r - 150
        ? "translateY(-10%) scale(1)"
        : "translateY(0) scale(1)";
  };
  window.addEventListener("resize", d, { passive: true });
  c._resizeHandler = d;
  d();
};

const hideSettings = () => {
  const c = document.getElementById("settingsModal");
  c.classList.remove("show");
  document.body.classList.remove("modal-open");
  if (c._resizeHandler) {
    window.removeEventListener("resize", c._resizeHandler);
    delete c._resizeHandler;
  }
};

  const c = document.getElementById("disableai");
  const s = document.getElementById("profile-button");

  if (c && s) {
    c.addEventListener("change", function () {
      setAI(this.checked);
      s.style.display = this.checked ? "block" : "none";
      s.classList.toggle("show", this.checked);
    });

    executeCommand("getprop persist.sys.azenithconf.AIenabled").then(
      ({ stdout: r }) => {
        const d = r.trim() === "0";
        c.checked = d;
        s.style.display = d ? "block" : "none";
        s.classList.toggle("show", d);
      }
    );
  }

const showProfilerSettings = async () => {
  const c = document.getElementById("profilermodal"),
    s = c.querySelector(".profiler-container");
  document.body.classList.add("modal-open");
  c.classList.add("show");

  const r = window.innerHeight;
  const d = () => {
    s.style.transform =
      window.innerHeight < r - 150
        ? "translateY(-10%) scale(1)"
        : "translateY(0) scale(1)";
  };
  window.addEventListener("resize", d, { passive: true });
  c._resizeHandler = d;
  d();
};

const hideProfilerSettings = () => {
  const c = document.getElementById("profilermodal");
  c.classList.remove("show");
  document.body.classList.remove("modal-open");
  if (c._resizeHandler) {
    window.removeEventListener("resize", c._resizeHandler);
    delete c._resizeHandler;
  }
};

const checkthermalcore = async () => {
  let { errno: c, stdout: s } = await executeCommand(
    "getprop persist.sys.azenithconf.thermalcore"
  );
  0 === c && (document.getElementById("thermalcore").checked = "1" === s.trim());
};

const setthermalcore = async (c) => {
  await executeCommand(
    c
      ? "setprop persist.sys.azenithconf.thermalcore 1 && /data/adb/modules/AZenith/system/bin/sys.azenith-utilityconf setthermalcore 1 &"
      : "setprop persist.sys.azenithconf.thermalcore 0 && /data/adb/modules/AZenith/system/bin/sys.azenith-utilityconf setthermalcore 0 &"
  );
};

const setupUIListeners = () => {
  const bannerBox = document.getElementById("bannerBox");
  const bannerInput = document.getElementById("bannerInput");
  const bannerLoader = document.getElementById("bannerLoader");
  const banner = document.getElementById("Banner");
  const avatar = document.getElementById("Avatar");
  const scheme = document.getElementById("Scheme");
  const reso = document.getElementById("Reso");

  if (avatar) avatar.src = AvatarZenith;
  if (scheme) scheme.src = SchemeBanner;
  if (reso) reso.src = ResoBanner;

  const updateBannerByTheme = () => {
    const isDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
    if (banner) banner.src = isDark ? BannerDarkZenith : BannerLightZenith;
  };

  updateBannerByTheme();  

  // Listen for system theme changes
  window
    .matchMedia("(prefers-color-scheme: dark)")
    .addEventListener("change", updateBannerByTheme);

  // Button Clicks
  document
    .getElementById("startButton")
    ?.addEventListener("click", startService);
    document
    .getElementById("applyperformance")
    ?.addEventListener("click", applyperformanceprofile);
  document
    .getElementById("applybalanced")
    ?.addEventListener("click", applybalancedprofile);
  document
    .getElementById("applypowersave")
    ?.addEventListener("click", applyecomode);
  document.getElementById("savelogButton")?.addEventListener("click", savelog);
  document.getElementById("FSTrim")?.addEventListener("click", applyFSTRIM);

  // Toggle Switches
  document
    .getElementById("fpsged")
    ?.addEventListener("change", (e) => setfpsged(e.target.checked));
  document
    .getElementById("jit")
    ?.addEventListener("change", (e) => setjit(e.target.checked));
  document
    .getElementById("disableai")
    ?.addEventListener("change", (e) => setAI(e.target.checked));
  document
    .getElementById("toast")
    ?.addEventListener("change", (e) => settoast(e.target.checked));
  document
    .getElementById("trace")
    ?.addEventListener("change", (e) => setdtrace(e.target.checked));
  document
    .getElementById("GPreload")
    ?.addEventListener("change", (e) => setGPreloadStatus(e.target.checked));
  document
    .getElementById("clearbg")
    ?.addEventListener("change", (e) => setRamBoostStatus(e.target.checked));
  document
    .getElementById("SFL")
    ?.addEventListener("change", (e) => setSFL(e.target.checked));
  document
    .getElementById("DThermal")
    ?.addEventListener("change", (e) => setDThermal(e.target.checked));
  document
    .getElementById("LiteMode")
    ?.addEventListener("change", (e) => setLiteModeStatus(e.target.checked));
  document
    .getElementById("schedtunes")
    ?.addEventListener("change", (e) => setschedtunes(e.target.checked));
  document
    .getElementById("thermalcore")
    ?.addEventListener("change", (e) => setthermalcore(e.target.checked));
  document
    .getElementById("logger")
    ?.addEventListener("change", (e) => setlogger(e.target.checked));
  document
    .getElementById("iosched")
    ?.addEventListener("change", (e) => setiosched(e.target.checked));
  document
    .getElementById("malisched")
    ?.addEventListener("change", (e) => setmalisched(e.target.checked));
  document
    .getElementById("DoNoDis")
    ?.addEventListener("change", (e) => setDND(e.target.checked));
  document
    .getElementById("logd")
    ?.addEventListener("change", (e) => setKillLog(e.target.checked));
  document
    .getElementById("Zepass")
    ?.addEventListener("change", (e) =>
      setBypassChargeStatus(e.target.checked)
    );

  // Select dropdowns
  document
    .getElementById("cpuGovernor")
    ?.addEventListener("change", (e) => setDefaultCpuGovernor(e.target.value));
  document
    .getElementById("GovernorPowersave")
    ?.addEventListener("change", (e) => setGovernorPowersave(e.target.value));
  document
    .getElementById("ioSchedulerBalanced")
    ?.addEventListener("change", (e) => setIObalance(e.target.value));
  document
    .getElementById("ioSchedulerPerformance")
    ?.addEventListener("change", (e) => setIOperformance(e.target.value));
  document
    .getElementById("ioSchedulerPowersave")
    ?.addEventListener("change", (e) => setIOpowersave(e.target.value));
  document
    .getElementById("cpuFreq")
    ?.addEventListener("change", (e) => setCpuFreqOffsets(e.target.value));
  document
    .getElementById("disablevsync")
    ?.addEventListener("change", (e) => setVsyncValue(e.target.value));

  // Open settings
  document
    .getElementById("settingsButton")
    ?.addEventListener("click", showSettings);
  document
    .getElementById("close-settings")
    ?.addEventListener("click", hideSettings);
  document.getElementById("disableai").addEventListener("change", function () {
  setAI(this.checked),
    document
      .getElementById("profile-button")
      .classList.toggle("show", this.checked);
  });
    
  // Profile Settings
  document
    .getElementById("profile-button")
    ?.addEventListener("click", showProfilerSettings);
  document
    .getElementById("close-profiler")
    ?.addEventListener("click", hideProfilerSettings);
    
  // Additional Settings
  document
    .getElementById("show-additional-settings")
    ?.addEventListener("click", showAdditionalSettings);
  document
    .getElementById("close-additional")
    ?.addEventListener("click", hideAdditionalSettings);

  // Preference Settings
  document
    .getElementById("show-preference-settings")
    ?.addEventListener("click", showPreferenceSettings);
  document
    .getElementById("close-preference")
    ?.addEventListener("click", hidePreferenceSettings);

  // Custom Resolution Settings
  document
    .getElementById("customreso")
    ?.addEventListener("click", showCustomResolution);
  document.getElementById("applyreso")?.addEventListener("click", async () => {
    await applyResolution();
    hideResoSettings();
  });
  document
    .getElementById("resetreso-btn")
    ?.addEventListener("click", hideResoSettings);
  document
    .getElementById("close-reso")
    ?.addEventListener("click", hideResoSettings);

  // Selectable resolutions
  document.querySelectorAll(".reso-option")?.forEach((btn) => {
    btn.addEventListener("click", () => selectResolution(btn));
  });
  
  // AZenith Save and Load Config
  document
    .getElementById("saveconfig")
    .onclick = async () => {
    await saveConfig();
  };

  document
    .getElementById("loadconfig").addEventListener("change", async (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const ok = await loadConfigFile(file);

    if (ok) {
      // Small delay so setprop finishes writing
      setTimeout(() => {
        location.reload();
      }, 500);
    }
  });

  // Color scheme buttons
  document
    .getElementById("colorschemebutton")
    ?.addEventListener("click", showColorScheme);
  document
    .getElementById("applybutton")
    ?.addEventListener("click", hidecolorscheme);
  document
    .getElementById("close-scheme")
    ?.addEventListener("click", hideSchemeSettings);

  // Gamelist modal buttons
  document
    .getElementById("editGamelistButton")
    ?.addEventListener("click", showGameListModal);
  document
    .getElementById("cancelButton")
    ?.addEventListener("click", hideGameListModal);
  document
    .getElementById("saveGamelistButton")
    ?.addEventListener("click", saveGameList);
  document
    .getElementById("close-gamelist")
    ?.addEventListener("click", hideGamelistSettings);  
};

let loopsActive = false;
let loopTimeout = null;
let heavyInitDone = false;
let cleaningInterval = null;
let heavyInitTimeouts = [];

const cancelAllTimeouts = () => {
  heavyInitTimeouts.forEach(clearTimeout);
  heavyInitTimeouts = [];
};

const schedule = (fn, delay = 0) => {
  const id = setTimeout(() => {
    try {
      fn();
    } finally {
      heavyInitTimeouts = heavyInitTimeouts.filter((t) => t !== id);
    }
  }, delay);
  heavyInitTimeouts.push(id);
};

const cleanMemory = () => {
  if (typeof globalThis.gc === "function") globalThis.gc();
};

const monitoredTasks = [
  { fn: checkServiceStatus, interval: 5000 },
  { fn: checkProfile, interval: 5000 },
  { fn: showRandomMessage, interval: 10000 },
];

const runMonitoredTasks = async () => {
  if (!loopsActive) return;
  const now = Date.now();
  if (!runMonitoredTasks.lastRun) runMonitoredTasks.lastRun = {};

  for (const task of monitoredTasks) {
    const last = runMonitoredTasks.lastRun[task.fn.name] || 0;
    if (now - last >= task.interval) {
      try {
        await task.fn();
      } catch (e) {
        console.warn(`Task ${task.fn.name} failed:`, e);
      }
      runMonitoredTasks.lastRun[task.fn.name] = Date.now();
    }
  }

  loopTimeout = setTimeout(runMonitoredTasks, 1000);
};

const startMonitoringLoops = () => {
  if (loopsActive) return;
  loopsActive = true;
  runMonitoredTasks();
};

const stopMonitoringLoops = () => {
  loopsActive = false;
  if (loopTimeout) clearTimeout(loopTimeout);
};

const observeVisibility = () => {
  document.addEventListener("visibilitychange", () => {
    if (document.hidden) {
      stopMonitoringLoops();
      cancelAllTimeouts();
      if (cleaningInterval) clearInterval(cleaningInterval);
    } else {
      startMonitoringLoops();
    }
  });
};

const heavyInit = async () => {
  if (heavyInitDone) return;
  heavyInitDone = true;

  cancelAllTimeouts();
  if (cleaningInterval) clearInterval(cleaningInterval);

  const loader = document.getElementById("loading-screen");
  if (loader) loader.classList.remove("hidden");
  document.body.classList.add("no-scroll");

  const stage1 = [checkProfile, checkServiceStatus, showRandomMessage];
  await Promise.all(stage1.map((fn) => fn()));

  const quickChecks = [    
    loadCpuGovernors,
    loadCpuFreq,    
    loadIObalance,
    loadIOperformance,
    loadIOpowersave,
    GovernorPowersave,
  ];
  await Promise.all(quickChecks.map((fn) => fn()));

  const heavyAsync = [
    checkCPUInfo,
    checkKernelVersion,
    getAndroidVersion,
    checkfpsged,
    checkLiteModeStatus,
    checkDThermal,
    checkiosched,
    checkGPreload,
    loadColorSchemeSettings,
  ];
  await Promise.all(heavyAsync.map((fn) => fn()));

  const heavySequential = [
    checkmalisched,
    checkAI,
    checkthermalcore,
    checkDND,
    checkdtrace,
    checkjit,
    checktoast,
    loadVsyncValue,
    checkBypassChargeStatus,
    checkschedtunes,
    checkSFL,
    checkKillLog,
    checklogger,
    checkRamBoost,
    detectResolution,
  ];
  for (const fn of heavySequential) {
    await fn();
  }

  startMonitoringLoops();
  observeVisibility();

  if (loader) loader.classList.add("hidden");
  document.body.classList.remove("no-scroll");

  cleaningInterval = setInterval(cleanMemory, 15000);
};

// Event Listeners
setupUIListeners();
heavyInit();
checkCPUInfo();
checkKernelVersion();
getAndroidVersion();    

